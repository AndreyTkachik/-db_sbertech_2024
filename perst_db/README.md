![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/1.png)

Perst — это объектно-ориентированная СУБД с открытым исходным кодом. Java и C# компактны, и Perst был реализован на смартфонах под управлением операционных систем Android Windows Phone (WP7). 
Perst был запущен в 2003 году в России. Он был разработан для достижения высокой производительности за счет тесной интеграции базы данных с языком программирования: Perst напрямую хранит данные в объектах языка. В 2006 году компания McObject LLC, расположенная в Иссакуа, штат Вашингтон, взяла на себя разработку Perst. Имеются разные виды подписок: бесплатная и платная.
Perst был впервые написан на Java и портирован на C#. Несмотря на то, что изначально Perst был разработан для настольного и серверного программного обеспечения, он также нашел применение для обеспечения управления базами данных для мобильных приложений, работающих на таких устройствах, как смартфоны.

Perst сам является database engine. Если вашим приложениям требуется встроенный движок базы данных и не требуется выполнять сложные SQL-запросы, и единственное, что вам нужно, - это иметь возможность сохранять / извлекать / находить объекты в базе данных, используя навигацию по ссылкам или индексированный поиск по ключам, то Perst - это то, что вам нужно. Это обеспечит гораздо лучшую производительность, чем реляционная база данных и другие (более сложные) объектно-ориентированные базы данных. 

Поддерживаются запросы следующего рода:
- Объектно-ориентированный с использованием различных методов поиска и итераций в классах Pest collection
-	Поиск по примерам (включая поиск по диапазону) – реализован с использованием многомерных индексов
-	JSQL – объектно-ориентированное подмножество SQL
- Полнотекстовый поиск: встроенная система полнотекстового поиска или интеграция с Lucene
- Собственные запросы и LINQ (предикат поиска, указанный в собственном коде)

```
import org.garret.perst.*;

public class Main {
    public static void main(String[] args) {
        Storage db = StorageFactory.getInstance().createStorage();

        // открываем базу данных
        db.open("test.dbs", 1_000_000);

        // создаем класс для хранения данных
        class Person extends Persistent {
            String name;
            int age;
        }

        // создаем индекс для поиска по имени
        db.createIndex(String.class, true);

        // добавляем объекты в базу данных
        Person person1 = new Person();
        person1.name = "Alice";
        person1.age = 30;
        db.makePersistent(person1);

        Person person2 = new Person();
        person2.name = "Bob";
        person2.age = 25;
        db.makePersistent(person2);

        // выполняем запрос
        Index<String, Person> nameIndex = (Index<String, Person>) db.getIndex(String.class);
        Person result = nameIndex.get("Alice");
        System.out.println(result.name + " " + result.age);

        // закрываем базу данных
        db.close();
    }
}
```

СУБД написана на языке Java. 

Обычно доступ к объектам осуществляется путем перехода от одного объекта к другому с использованием ссылок. Но часто требуется определить местонахождение объекта по его ключу. В JDK, the Hashtable или the HashMap для этой цели можно использовать класс. В базах данных обычно требуется более сложный поиск. Я не хочу реализовывать полный язык SQL в Perst, потому что это сразу делает СУБД огромной и медленной. Но в большинстве случаев приложение выполняет только очень простые запросы, используя точное совпадение или диапазон ключей. Это делается в Perst с помощью интерфейсов Index и IndexField . Первый интерфейс используется для независимой спецификации ключа и связанного с ним значения. IndexField интерфейс позволяет индексировать объекты, используя одно из полей этого объекта (ключевое поле).
Индексы создаются в Perst с использованием методов Storage.createIndex или the Storage.createFieldIndex. Может быть несколько реализаций индекса, но прямо сейчас предоставляется только одна реализация, основанная на B + Tree (потому что B + Tree является наиболее эффективной структурой для дисковых баз данных). Методы из Index и the FieldIndex интерфейсы позволяют добавлять, удалять и находить объекты по ключу. Поиск можно выполнить либо путем указания точного значения ключа, либо путем указания диапазона значений ключа (верхняя или нижняя граница или оба из них могут быть пропущены или могут быть объявлены как исключающие или включающие). Таким образом, можно выполнять следующие типы поиска:

1.	ключ равен значению
2.	ключ принадлежит [MIN_VAL, MAX_VAL]
3.	ключ принадлежит [MIN_VAL, MAX_VAL)
4.	ключ принадлежит (MIN_VAL, MAX_VAL]
5.	ключ принадлежит (MIN_VAL, MAX_VAL)
6.	ключ больше, чем MIN_VAL
7.	ключ больше или равен MIN_VAL
8.	значение ключа меньше MAX_VAL
9.	ключ меньше или равен MAX_VAL

Ниже приведена таблица всех поддерживаемых индексов в Perst:

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/2.png)

Запросы в Perst выполняются или при помощи индексов, предоставляемые СУБД, или при помощи JSQL - подмножества языка SQL, которое может использоваться для выбора экземпляров объектов в соответствии с условием выбора. В JSQL используется обозначение, которое более популярно в объектно-ориентированном программировании, чем для реляционной базы данных. Строки таблицы рассматриваются как экземпляры объектов, а таблица - как класс этих объектов. В отличие от SQL, JSQL ориентирован на работу с объектами, а не с кортежами SQL. Таким образом, результатом выполнения каждого запроса является набор объектов одного класса.

Понятия «план запросов» - нет.

В Perst имеются транзакции. Perst использует теневой механизм для реализации транзакций. Когда объект изменяется в первый раз во время транзакции, создается тень объекта, а исходный объект сохраняется неизменным. Если объект обновляется несколько раз во время транзакции, тень создается только один раз. Поскольку в Perst используются тени, ему не нужен файл журнала транзакций. Следовательно, в Perst длительные транзакции не приведут к переполнению журнала транзакций, как в большинстве других СУБД. Поддерживает ACID, достаточно быстрое восстановление данных. Блокировки есть на уровне файлов, на уровне базы данных и Fine grain (объектно-ориентированная) блокировка. Блокировать может либо пессимистично: ресурс заблокирован до получения доступа, либо оптимистично: конфликты обнаруживаются на этапе фиксации. Уровни изоляции: совместные транзакции, повторяющиеся чтения, упорядочиваемые транзакции.

Процедура восстановления в Perst тривиальна. Существует два экземпляра object index, один из которых текущий, а другой соответствует согласованному состоянию базы данных. Когда база данных открыта, Perst проверяет заголовок базы данных, чтобы определить, была ли база данных закрыта нормально. Если нет (в заголовке базы данных установлен флаг dirty), то Perst выполняет восстановление базы данных. Восстановление очень похоже на откат транзакции. Индикатор текущего индекса в заголовке объекта базы данных используется для определения индекса, соответствующего согласованному состоянию базы данных, и дескрипторы объектов из этого индекса копируются в другой объектный индекс, устраняя все изменения, внесенные незафиксированной транзакцией. Пока единственным действием, выполняемым процедурой восстановления, является копирование индекса объекта (в действительности копируются только дескрипторы, имеющие разные значения в текущем и теневом индексах, чтобы уменьшить количество измененных страниц), а размер индекса объекта невелик, восстановление может быть выполнено очень быстро. Быстрые процедуры восстановления сокращают время простоя приложения.

Информации о Partitioning или Sharding в Perst нет. Однако стоит заметить, чтобы достичь работу этих механизмов достаточно разбираться в работе языка Java, а также знание основных понятий в ООП.

Perst не подходит как аналитическая база данных, поэтому Data Mining, Data Warehousing и OLAP невозможно применить.

Perst поддерживает шифрование базы данных, используя специальную реализацию файла базы данных, которая выполняет шифрование/дешифрование данных с помощью предоставленного ключа шифрования. Perst использует метод шифрования RC4. Шифрование выполняется на уровне страницы: страница шифруется перед записью на диск и расшифровывается при загрузке в пул страниц. База данных открывается с помощью специальной версии метода Storage.open, для которой требуется ключ шифрования: 

```public void open(String filePath, long pagedpoolsize, String cipherKey);```

Сообщество Perst очень маленькое. Легче даже сказать, что его вовсе нет. У СУБД есть платная и бесплатная лицензии. Поддержкой обеих версий занимается сама компания. При проверке функционала и использовании СУБД, McObject просит делиться своим опытом работы, дабы бальше продолжать развивать Perst.

Данные для работы и основные демобазы с некоторыми возможностями СУБД находятся в архиве, который Perst рассылает людям, проявившие желания заниматься или использовать данную БД. Ссылки на получени исходников со всей нужной информацией:

- [Perst for Java](https://www.mcobject.com/try-perst-and-perst-lite-for-java/)
- [Perst for .NET](https://www.mcobject.com/try-perst-dotnet/)

Открытых источников по обучению работы с данной СУБД – нет, однако McObject предлагает напрямую задавать им вопросы по поводу работы их СУБД, также имеются открытые технические документации и некий мануал, в котором описан процесс работы с Perst, а также его возможности.

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/3.png)

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/4.png)

Чтобы быть в курсе происходящего и обновлений в БД, достаточно иногда мониторить основной [сайт](https://www.mcobject.com/) разработчиков, чтобы получить нужную информацию.

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/5.png)


