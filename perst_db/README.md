![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/1.png)

Perst — это объектно-ориентированная СУБД с открытым исходным кодом. Java и C# компактны, и Perst был реализован на смартфонах под управлением операционных систем Android Windows Phone (WP7). 
Perst был запущен в 2003 году в России. Он был разработан для достижения высокой производительности за счет тесной интеграции базы данных с языком программирования: Perst напрямую хранит данные в объектах языка. В 2006 году компания McObject LLC, расположенная в Иссакуа, штат Вашингтон, взяла на себя разработку Perst. Имеются разные виды подписок: бесплатная и платная.
Perst был впервые написан на Java и портирован на C#. Несмотря на то, что изначально Perst был разработан для настольного и серверного программного обеспечения, он также нашел применение для обеспечения управления базами данных для мобильных приложений, работающих на таких устройствах, как смартфоны.

Perst сам является database engine. Если вашим приложениям требуется встроенный движок базы данных и не требуется выполнять сложные SQL-запросы, и единственное, что вам нужно, - это иметь возможность сохранять / извлекать / находить объекты в базе данных, используя навигацию по ссылкам или индексированный поиск по ключам, то Perst - это то, что вам нужно. Это обеспечит гораздо лучшую производительность, чем реляционная база данных и другие (более сложные) объектно-ориентированные базы данных. 

Поддерживаются запросы следующего рода:
- Объектно-ориентированный с использованием различных методов поиска и итераций в классах Pest collection
-	Поиск по примерам (включая поиск по диапазону) – реализован с использованием многомерных индексов
-	JSQL – объектно-ориентированное подмножество SQL
- Полнотекстовый поиск: встроенная система полнотекстового поиска или интеграция с Lucene
- Собственные запросы и LINQ (предикат поиска, указанный в собственном коде)

```
import org.garret.perst.*;

public class Main {
    public static void main(String[] args) {
        Storage db = StorageFactory.getInstance().createStorage();

        // открываем базу данных
        db.open("test.dbs", 1_000_000);

        // создаем класс для хранения данных
        class Person extends Persistent {
            String name;
            int age;
        }

        // создаем индекс для поиска по имени
        db.createIndex(String.class, true);

        // добавляем объекты в базу данных
        Person person1 = new Person();
        person1.name = "Alice";
        person1.age = 30;
        db.makePersistent(person1);

        Person person2 = new Person();
        person2.name = "Bob";
        person2.age = 25;
        db.makePersistent(person2);

        // выполняем запрос
        Index<String, Person> nameIndex = (Index<String, Person>) db.getIndex(String.class);
        Person result = nameIndex.get("Alice");
        System.out.println(result.name + " " + result.age);

        // закрываем базу данных
        db.close();
    }
}
```

СУБД написана на языке Java. 

Обычно доступ к объектам осуществляется путем перехода от одного объекта к другому с использованием ссылок. Но часто требуется определить местонахождение объекта по его ключу. В JDK, the Hashtable или the HashMap для этой цели можно использовать класс. В базах данных обычно требуется более сложный поиск. Я не хочу реализовывать полный язык SQL в Perst, потому что это сразу делает СУБД огромной и медленной. Но в большинстве случаев приложение выполняет только очень простые запросы, используя точное совпадение или диапазон ключей. Это делается в Perst с помощью интерфейсов Index и IndexField . Первый интерфейс используется для независимой спецификации ключа и связанного с ним значения. IndexField интерфейс позволяет индексировать объекты, используя одно из полей этого объекта (ключевое поле).
Индексы создаются в Perst с использованием методов Storage.createIndex или the Storage.createFieldIndex. Может быть несколько реализаций индекса, но прямо сейчас предоставляется только одна реализация, основанная на B + Tree (потому что B + Tree является наиболее эффективной структурой для дисковых баз данных). Методы из Index и the FieldIndex интерфейсы позволяют добавлять, удалять и находить объекты по ключу. Поиск можно выполнить либо путем указания точного значения ключа, либо путем указания диапазона значений ключа (верхняя или нижняя граница или оба из них могут быть пропущены или могут быть объявлены как исключающие или включающие). Таким образом, можно выполнять следующие типы поиска:

1.	ключ равен значению
2.	ключ принадлежит [MIN_VAL, MAX_VAL]
3.	ключ принадлежит [MIN_VAL, MAX_VAL)
4.	ключ принадлежит (MIN_VAL, MAX_VAL]
5.	ключ принадлежит (MIN_VAL, MAX_VAL)
6.	ключ больше, чем MIN_VAL
7.	ключ больше или равен MIN_VAL
8.	значение ключа меньше MAX_VAL
9.	ключ меньше или равен MAX_VAL

Ниже приведена таблица всех поддерживаемых индексов в Perst:

|Интерфейс|Описание|Тип ключа|Реализация|Создано|
| --- | --- | --- | --- | --- |
|Index|Индекс с явно указанным ключом, используемый для запросов точного соответствия или диапазона|скалярная, строковая или ссылочная|B + Tree|```Storage.createIndex(Class type, boolean unique)```|
|Index|То же, что и выше, но при условии, что может быть много повторяющихся значений ключа|скалярная, строковая или ссылочная|B + Tree|```Storage.createThinkIndex(Class type)```|
|Index|Индекс произвольного доступа, оптимизированный для доступа к элементам как по ключу, так и по позиции|скалярная, строковая или ссылочная|B + Tree|```Storage.createRandomAccessIndex(Class type, boolean unique)```|
|FieldIndex|Индекс, созданный для одного из полей объекта|скалярная, строковая или ссылочная|B + Tree|```Storage.createFieldIndex(Class type, String fieldName, boolean unique)```|
|FieldIndex|Индекс поля произвольного доступа, оптимизированный для доступа к элементам как по ключу, так и по позиции|скалярная, строковая или ссылочная|B + Tree|```Storage.createRandomAccessFieldIndex(Class type, String fieldName, boolean unique)```|
|MultidimensionalIndex|Многомерный индекс позволяет выбирать объекты, используя условия поиска по различным полям. Этот индекс обеспечивает лучшую производительность, чем традиционные индексы, если в запросе нет ни одного поля с хорошей избирательностью. В случае традиционных индексов (таких как B-Tree) необходимо объединять большие наборы результатов или выполнять последовательный поиск среди большого количества объектов. Составной индекс позволяет выбрать объект только в том случае, если указаны все ключи (или хотя бы префиксные ключи). А многомерный индекс позволяет выполнять поиск одновременно с учетом всех указанных ограничений. Но поскольку она реализована с использованием двоичного дерева, узлы которого содержат ссылки на индексируемые объекты, этот индекс эффективен в основном для баз данных в памяти или в случаях, когда все пройденные объекты умещаются в памяти.|скалярный, строковый или любой другой сопоставимый тип|KD-Tree|```Storage.createMultidimensionalIndex(Class cls, String[] fieldNames)``` или ```Storage.createMultidimensionalIndex(MultidimensionalComparator comparator)```|
|BitIndex|Битовый индекс для поиска объекта по растровой карте свойств|постоянный объект|B + Tree|```Storage.createBitIndex()```|
|IPersistentSet|Набор постоянных объектов|постоянный объект|B + Tree|```Storage.createSet()```|
|IPersistentSet|Масштабируемый набор постоянных объектов (может эффективно обрабатывать как небольшое, так и большое количество элементов)|постоянный объект|Link or B+Tree|```Storage.createScalableSet()```|
|IPersistentList|Список постоянных объектов , обеспечивающих произвольный доступ|постоянный объект|B + Tree|```Storage.createList()```|
|IPersistentList|Масштабируемый список постоянных объектов (может эффективно обрабатывать как небольшое, так и большое количество элементов)|постоянный объект|Link or B+Tree|```Storage.createScalableList()```|
|IPersistentMap|Масштабируемая карта постоянных объектов (может эффективно обрабатывать как небольшое, так и большое количество элементов)|постоянный объект|Sorted array or B+Tree|```Storage.createMap()```|
|SpatialIndex|Индекс для пространственных объектов с целочисленными координатами|Rectangle|R-Tree|```Storage.createSpatialIndex()```|
|SpatialIndexR2|Индекс для пространственных объектов с реальными координатами|RectangleR2|R-Tree|```Storage.createSpatialIndexR2()```|
|SortedCollection|Индексирование с помощью определяемого пользователем компаратора|Любой|T-Tree|```Storage.createSortedCollection(PersistentComparator comparator, boolean unique)```|
|FullTextIndex|Полнотекстовый индекс|любой текст|B-Tree based inverse index|```Storage.createFieldIndex(FullTextSearchHelper helper)```|

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/2.png)

Запросы в Perst выполняются или при помощи индексов, предоставляемые СУБД, или при помощи JSQL - подмножества языка SQL, которое может использоваться для выбора экземпляров объектов в соответствии с условием выбора. В JSQL используется обозначение, которое более популярно в объектно-ориентированном программировании, чем для реляционной базы данных. Строки таблицы рассматриваются как экземпляры объектов, а таблица - как класс этих объектов. В отличие от SQL, JSQL ориентирован на работу с объектами, а не с кортежами SQL. Таким образом, результатом выполнения каждого запроса является набор объектов одного класса.

Понятия «план запросов» - нет.

В Perst имеются транзакции. Perst использует теневой механизм для реализации транзакций. Когда объект изменяется в первый раз во время транзакции, создается тень объекта, а исходный объект сохраняется неизменным. Если объект обновляется несколько раз во время транзакции, тень создается только один раз. Поскольку в Perst используются тени, ему не нужен файл журнала транзакций. Следовательно, в Perst длительные транзакции не приведут к переполнению журнала транзакций, как в большинстве других СУБД. Поддерживает ACID, достаточно быстрое восстановление данных. Блокировки есть на уровне файлов, на уровне базы данных и Fine grain (объектно-ориентированная) блокировка. Блокировать может либо пессимистично: ресурс заблокирован до получения доступа, либо оптимистично: конфликты обнаруживаются на этапе фиксации. Уровни изоляции: совместные транзакции, повторяющиеся чтения, упорядочиваемые транзакции.

Процедура восстановления в Perst тривиальна. Существует два экземпляра object index, один из которых текущий, а другой соответствует согласованному состоянию базы данных. Когда база данных открыта, Perst проверяет заголовок базы данных, чтобы определить, была ли база данных закрыта нормально. Если нет (в заголовке базы данных установлен флаг dirty), то Perst выполняет восстановление базы данных. Восстановление очень похоже на откат транзакции. Индикатор текущего индекса в заголовке объекта базы данных используется для определения индекса, соответствующего согласованному состоянию базы данных, и дескрипторы объектов из этого индекса копируются в другой объектный индекс, устраняя все изменения, внесенные незафиксированной транзакцией. Пока единственным действием, выполняемым процедурой восстановления, является копирование индекса объекта (в действительности копируются только дескрипторы, имеющие разные значения в текущем и теневом индексах, чтобы уменьшить количество измененных страниц), а размер индекса объекта невелик, восстановление может быть выполнено очень быстро. Быстрые процедуры восстановления сокращают время простоя приложения.

Информации о Partitioning или Sharding в Perst нет. Однако стоит заметить, чтобы достичь работу этих механизмов достаточно разбираться в работе языка Java, а также знание основных понятий в ООП.

Perst не подходит как аналитическая база данных, поэтому Data Mining, Data Warehousing и OLAP невозможно применить.

Perst поддерживает шифрование базы данных, используя специальную реализацию файла базы данных, которая выполняет шифрование/дешифрование данных с помощью предоставленного ключа шифрования. Perst использует метод шифрования RC4. Шифрование выполняется на уровне страницы: страница шифруется перед записью на диск и расшифровывается при загрузке в пул страниц. База данных открывается с помощью специальной версии метода Storage.open, для которой требуется ключ шифрования: 

```public void open(String filePath, long pagedpoolsize, String cipherKey);```

Сообщество Perst очень маленькое. Легче даже сказать, что его вовсе нет. У СУБД есть платная и бесплатная лицензии. Поддержкой обеих версий занимается сама компания. При проверке функционала и использовании СУБД, McObject просит делиться своим опытом работы, дабы бальше продолжать развивать Perst.

Данные для работы и основные демобазы с некоторыми возможностями СУБД находятся в архиве, который Perst рассылает людям, проявившие желания заниматься или использовать данную БД. Ссылки на получени исходников со всей нужной информацией:

- [Perst for Java](https://www.mcobject.com/try-perst-and-perst-lite-for-java/)
- [Perst for .NET](https://www.mcobject.com/try-perst-dotnet/)

Открытых источников по обучению работы с данной СУБД – нет, однако McObject предлагает напрямую задавать им вопросы по поводу работы их СУБД, также имеются открытые технические документации и некий мануал, в котором описан процесс работы с Perst, а также его возможности.

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/3.png)

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/4.png)

Чтобы быть в курсе происходящего и обновлений в БД, достаточно иногда мониторить основной [сайт](https://www.mcobject.com/) разработчиков, чтобы получить нужную информацию.

![alt text](https://github.com/AndreyTkachik/db_sbertech_2024/blob/hw4/perst_db/pics/5.png)


